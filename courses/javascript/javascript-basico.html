<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Curso básico de Javascript</title>
    <link rel="icon" href="../../images/favicon.png" type="img/text" />
    <link
      href="https://fonts.googleapis.com/css?family=Pacifico|Source+Sans+Pro&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../../css/styles.css" />
    <link rel="stylesheet" href="../../fonts/style.css" />
  </head>
  <body>
    <div class="app">
      <div class="app-react-basico">
        <header class="header">
          <div class="container-general">
            <nav class="header-menu">
              <ul class="header-menu__list menu-left">
                <li class="header-menu__list--item">
                  <a class="link" href="../../index.html">Inicio</a>
                </li>
                <li class="header-menu__list--item">
                  <a class="link" href="">Carreras</a>
                </li>
              </ul>
              <figure class="header-menu__logo">
                <a href="../../index.html"
                  ><img
                    class="header-menu__logo--img"
                    src="../../images/logo_white.png"
                    alt="logo carlos zabala"
                /></a>
              </figure>
              <ul class="header-menu__list menu-right">
                <li class="header-menu__list--item">
                  <a class="link" href="">Me</a>
                </li>
                <li class="header-menu__list--item">
                  <a class="link" href="">Contacto</a>
                </li>
              </ul>
            </nav>
          </div>
        </header>
        <section class="hero-course">
          <div class="container-general">
            <h1 class="hero-course__title">Curso básico de Javascript</h1>
            <p class="hero-course__description">
              A lo largo del curso aprenderemos las bases sólidas para dominar
              el lenguaje JavaScript. Veremos desde lo más básico como:
              variables, tipos de datos y operadores, e iremos avanzando con los
              condicionales y las estructuras de control. Luego veremos los
              conceptos relacionados con asincronismo, uno de los aspectos
              fundamentales de JavaScript, usando callbacks, promesas y async
              await.
            </p>
            <div class="hero-course__buttons">
              <a
                target="_blank"
                href="https://platzi.com/clases/fundamentos-javascript/"
                class="btn btn--primary"
                >Curso platzi</a
              >
            </div>
          </div>
        </section>
        <section class="course-class">
          <div class="course-class__left" id="course-class__left">
            <div class="course-class__left--container">
              <nav class="course-class__menu">
                <ul>
                  <li>
                    <a class="link course-class__menu--a" href="#variables"
                      >Variables</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#functions"
                      >Funciones</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#function-scope"
                      >Alcance de las funciones</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#objects"
                      >Objetos</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#compare"
                      >Comparaciones</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#conditional"
                      >Condicionales</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#arrow-function"
                      >Arrow Functions</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#for"
                      >Estructuras repetitivas: for</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#while"
                      >Estructuras repetitivas: while</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#do-while"
                      >Estructuras repetitivas: do while</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#switch"
                      >Condicional múltiple: switch</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#array"
                      >Arrays</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#class"
                      >Clases</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#this">This</a>
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#class-ecma"
                      >Clases ECMAScript</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#async"
                      >Asincronismo</a
                    >
                  </li>
                  <li>
                    <a
                      class="link course-class__menu--a"
                      href="#time-javascript"
                      >Tiempo en JavaScript</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#callbacks"
                      >Callbacks</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#promise"
                      >Promesas</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#async-await"
                      >Async-await</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#context-function"
                      >Contexto de una función</a
                    >
                  </li>
                </ul>
              </nav>
            </div>
          </div>
          <div class="course-class__content">
            <i class="icon-menu icon course-class__icon-menu" id="btn-menu"></i>
            <article class="course-class__section" id="variables">
              <h2 class="course-class__section--title">Variables</h2>
              <p>
                Para declarar una variable se hace de la siguiente forma, en el
                ejemplo se declara y se le asigna un valor:
              </p>
              <pre class="code">
  
                <span class="code-var">var</span> nombreVariable <span class="code-sym">=</span> <span class="code-text">"valor de la variable"</span>
              </pre>
              <div class="note">
                <p>
                  Recomendado usar en js la comilla simple para String ('').
                  <br />El punto y coma se puede incluir o no, es una convención
                  escribirlo. Pero hay ciertos casos en los que sí hay que
                  colocarlo, son acciones puntuales.
                </p>
              </div>
              <p>
                Js lenguaje débilmente tipado, en una variable se pueden asignar
                tanto números y textos, ej:
              </p>
              <pre class="code">
  
                edad <span class="code-sym">=</span> 28
                edad <span class="code-sym">=</span> <span class="code-text">'28'</span>
              </pre>
              <h3>Variables: Strings</h3>
              <p>
                Los strings son cadenas de texto. Para indicar que estamos
                usando una cadena de texto debemos de colocar las comillas
                simples.
              </p>
              <pre class="code">
  
                <span class="code-comment">// <span class="t-bold">toUpperCase</span>, que sirve para transformar un String a mayúsculas.</span>
                <span class="code-var">var</span> nombreEnMayusculas <span class="code-sym">=</span> name.<span class="code-var">toUpperCase</span>()
  
                <span class="code-comment">// <span class="t-bold">toLowerCase</span>, que sirve para transformar un String a minúsculas.</span>
                <span class="code-var">var</span> nombreEnMinuscula <span class="code-sym">=</span> name.<span class="code-var">toLowerCase</span>()
  
                <span class="code-comment">// imprimir primera letra del nombre <span class="t-bold">(charAt(posicion))</span>.</span>
                <span class="code-var">var</span> primeraLetraNombre <span class="code-sym">=</span> name.<span class="code-var">charAt</span>(0)
  
                <span class="code-comment">// cantidad de letras del nombre <span class="t-bold">length</span>.</span>
                <span class="code-var">var</span> cantidadLetrasNombre <span class="code-sym">=</span> name.<span class="code-var">length</span>
  
                <span class="code-comment">// extraer texto de un string con <span class="t-bold">substr</span>(inicio, cuantasLetras).</span>
                <span class="code-var">var</span> str <span class="code-sym">=</span> name.<span class="code-var">substr</span>(1, 2)
  
                <span class="code-comment">// Imprimir ultima letra del nombre</span>
                <span class="code-var">var</span> ultimaLetraDelNombre <span class="code-sym">=</span> name.<span class="code-var">substr</span>(name.<span class="code-var">length</span> - 1, 1)
  
                <span class="code-comment">//Para concatenar texto se usa el signo (+), y para imprimir en consola se usa la función console.log</span>
                <span class="code-var">console</span>.log(<span class="code-text">'hello, my name is '</span> <span class="code-sym">+</span> name <span class="code-sym">+</span> <span class="code-text"> ' ' </span> <span class="code-sym">+</span> lastName)
              </pre>
              <p>
                Si queremos evitar la concatenación de texto con (+), podemos
                usar
                <span class="t-bold">Interpolación</span> de texto que ofrece
                JS. Para usarla podemos definir una cadena de texto por medio de
                las comillas invertidas (``), ejemplo:
              </p>
              <pre class="code">
  
                <span class="code-var">var</span> interpolacion <span class="code-sym">=</span> <span class="code-text">`${Aquí se puede poner código js}`</span>
                <span class="code-var">var</span> nombreCompleto <span class="code-sym">=</span> <span class="code-text">`Hello, my name is ${name} ${lastName}`</span>
              </pre>
              <h3>Variables: Número</h3>
              <p>
                Recuerda que en operaciones con decimales debemos realizar
                operaciones adicionales para conseguir un resultado preciso. Ej.
                var total = ( precioDeVino * 100 * 3) / 100. <br />
                Para redondear una operación se utiliza la función:
                <span class="t-bold">Math.round</span>
              </p>
              <pre class="code">
  
                <span class="code-var">let</span> precioVino = 200.3
                <span class="code-var">let</span> total = Math.<span class="code-var">round</span>(precioVino * 3) / 100 <span class="code-comment">//Redondear sin importar los decimales</span>
                <span class="code-var">let</span> totalStr = total.<span class="code-var">toFixed</span>(2) <span class="code-comment">//Agregar decimales convierte el valor en un string</span>
                <span class="code-var">let</span> total2 = <span class="code-var">parseFloat</span>(totalStr) <span class="code-comment">//Convierte el string nuevamente a número</span>
              </pre>
              <h3>Diferencias entre LET vs VAR</h3>
              <p>
                let permite declarar variables limitando su alcance (scope) al
                bloque, declaración, o expresión donde se está usando. Lo
                anterior diferencia la expresión let de la palabra reservada
                var, la cual define una variable global o local en una función
                sin importar el ámbito del bloque.
              </p>
              <p>
                Cuando usamos let dentro de un bloque, podemos limitar el
                alcance de la variable a dicho bloque. Notemos la diferencia con
                var, cuyo alcance reside dentro de la función donde ha sido
                declarada la variable.
              </p>
              <pre class="code">
  
                <span class="code-var">var</span> a = 5; <span class="code-var">var</span> b = 10;
                
                <span class="code-sym">if</span>(a === 5){
                  <span class="code-var">let</span> a = 4; <span class="code-comment">// El alcance es dentro del bloque if</span>
                  <span class="code-var">var</span> b = 1; <span class="code-comment">// El alcance es global</span>
  
                  console.<span class="code-var">log</span>(a) <span class="code-comment">//4</span>
                  console.<span class="code-var">log</span>(b) <span class="code-comment">//1</span>
                }
  
                console.<span class="code-var">log</span>(a) <span class="code-comment">//5</span>
                console.<span class="code-var">log</span>(b) <span class="code-comment">//1</span>
              </pre>
              <p>
                "var" es la manera más antigua de declarar variables. No es muy
                estricta en cuanto al alcance, ya que, al declarar variables de
                esta forma, dichas variables podrán ser accedidas, e incluso
                modificadas, tanto dentro como fuera de los bloques internos en
                una función. <br />
                Con "let" por otra parte, el alcance se reduce al bloque (las
                llaves) en el cual la variable fue declarada. Fuera de este
                bloque la variable no existe. Una vez declarada la variable con
                let, no se puede volver a declarar con en ninguna otra parte de
                la función. <br />
                "const" al igual que "let" se define en el contexto o alcance de
                un bloque, a diferencia de let y var, las varibles definidas
                como constantes (const), ya no podrán ser modificadas ni
                declaradas nuevamente, en ninguna otra parte de la función o el
                contexto en el que ya existen. <br />
                La recomendación es reducir siempre al mínimo el alcance de
                nuestras variables, por lo que se debe usar let en lugar de var
                mientras sea posible.
              </p>
            </article>
            <article class="course-class__section" id="functions">
              <h2 class="course-class__section--title">Funciones</h2>
              <p>
                Las funciones son
                <span class="t-bold">fracciones de código reutilizable</span>.
                Para definir una función utilizaremos la palabra reservada
                "function". <br />
                Delimitamos el cuerpo de la función usando llaves { }. Los
                parámetros de la función son variables que se pasan a la función
                escribiéndolos entre paréntesis (). <br />
                Definir funciones nos sirve para reutilizar código. JavaScript
                es un lenguaje interpretado, esto quiere decir que intentará
                ejecutar el código sin importar si los parámetros que le pasemos
                a la función estén invertidos o incluso incompletos.
              </p>
              <pre class="code">

                <span class="code-var">var</span> nombre = <span class="code-text">'Carlos'</span> , apellido = <span class="code-text">'Zabala'</span>, edad = 21

                <span class="code-var">function</span> <span class="code-function">imprimirEdad</span>(nombre, apellido, edad){
                  console.<span class="code-var">log</span>(<span class="code-text">`${n} ${a} tiene ${e} años`</span>)
                }

                <span class="code-function">imprimirEdad</span>(nombre, apellido, edad) <span class="code-comment">//Carlos Zabala tiene 21 años</span>
                <span class="code-function">imprimirEdad</span>() <span class="code-comment">//undefined undefined tiene undefined años</span>
                <span class="code-function">imprimirEdad</span>(<span class="code-text">'Juan'</span>, <span class="code-text">'Diaz'</span>, 21) <span class="code-comment">//Juan Diaz tiene 21 años</span>
                <span class="code-function">imprimirEdad</span>(21, 5, <span class="code-text">'Lopez'</span>) <span class="code-comment">//21 5 tiene lopez años</span>
              </pre>
              <h3>Funciones que retornan valores</h3>
              <p>
                <span class="t-bold">Return</span> detiene la ejecución de una
                función y devuelve el valor de esa función. Las variables
                definidas con const se comportan como las variables, excepto que
                no pueden ser reasignadas. Las constantes pueden ser declaradas
                en mayúsculas o minúsculas. Pero por convención, para
                distinguirlas del resto de variables, se escribe todo en
                mayúsculas.
              </p>
              <pre class="code">

                <span class="code-var">function</span> <span class="code-function">esMayorEdad</span>(persona){
                  <span class="code-sym">return</span> persona.edad >= MAYORIA_DE_EDAD <span class="code-comment">// retorna true / false</span>
                }
              </pre>
            </article>
            <article class="course-class__section" id="function-scope">
              <h2 class="course-class__section--title">
                El alcance de las funciones
              </h2>
              <p>
                En esta clase hablaremos del alcance que tienen las funciones.
                Si una variable no está definida dentro del cuerpo de una
                función hablamos de una variable global. Por el contrario, una
                variable definida dentro de una función es una variable local.
                Para que la ejecución de una función no modifique una variable
                global usamos parámetros en lugar de pasar directamente la
                variable. Es posible utilizar el mismo nombre para una variable
                global y para el parámetro de una función con un alcance local.
              </p>
              <div class="note">
                <p>
                  A que variables la función puede acceder y que valor tomara
                  esa variable dentro de la función. <br />
                  <span class="t-bold">Variable global</span>: Variable que no
                  está definida dentro de una función sino por fuera de ella.
                </p>
              </div>
              <p>
                Al hacer referencia directa a una variable global dentro de una
                función, podemos modificar su valor, esto se le denomina
                <span class="t-bold">sideEfect</span>, y esto lo vamos a querer
                evitar. Para acceder a la variable global, hacemos referencia al
                objeto global, en este caso por estar en el browser accedemos
                con <span class="t-bold">window.nombre</span>.
              </p>
              <pre class="code">

                <span class="code-comment">//Accediendo a una variable global (no hacer)</span>
                
                <span class="code-var">var</span> nombre = <span class="code-text">'Cosme Fulanito'</span>

                <span class="code-var">function</span> <span class="code-function">imprimirNombreMayusculas</span>(){
                  nombre = nombre.<span class="code-var">toUpperCase</span>()
                  console.<span class="code-var">log</span>(nombre)
                }

                <span class="code-function">imprimirNombreMayusculas</span>()

                <span class="code-comment">//Accediendo a los parametros de la función (recomendado)</span>
                <span class="code-comment">//El alcance de la siguiente función solo es para la variable local que le llega por parámetro</span>
                <span class="code-var">function</span> <span class="code-function">imprimirNombreMayusculas</span>(nombre){
                  nombre = nombre.<span class="code-var">toUpperCase</span>()
                  console.<span class="code-var">log</span>(nombre)
                }

                <span class="code-function">imprimirNombreMayusculas</span>(nombre)
              </pre>
              <div class="note">
                <p>
                  SideEfect funciones que modifican variables que "no le
                  corresponde".
                </p>
              </div>
            </article>
            <article class="course-class__section" id="objects">
              <h2 class="course-class__section--title">Objetos</h2>
              <p>
                Vamos a empezar a trabajar con objetos, veremos cómo
                declararlos, cuáles son sus ventajas, cómo asignarles atributos
                y cómo trabajar con ellos dentro de las funciones. <br />
                Los objetos se definen delimitados mediante llaves {} <br />
                Un atributo se compone de una clave (key) y un valor (value),
                que se separan entre sí por dos puntos ":". Los valores pueden
                ser de tipo string, número, booleano, etc. Cada atributo está
                separado del siguiente por una coma. Un objeto puede tener todos
                los atributos que sean necesarios.
              </p>
              <p>
                Las últimas versiones de JavaScript nos permiten
                <span class="t-bold">desglosar</span> el objeto para acceder
                únicamente al atributo que nos interesa. Esto se consigue
                encerrando el nombre del atributo entre llaves { }.
              </p>
              <pre class="code">

                <span class="code-comment">//Creación de objetos</span>
                <span class="code-var">var</span> carlos = {
                  nombre : <span class="code-text">'Carlos'</span>,
                  apellido : <span class="code-text">'Zabala'</span>,
                  edad : 22
                }

                <span class="code-comment">//Una nueva funcionalidad de js es pedir el atributo de un objeto en los parametros para esto se usan las llaves {nombreAtributo}</span>
                <span class="code-var">function</span> <span class="code-function">imprimirNombreMayusculas</span>({nombre}){
                  console.<span class="code-var">log</span>(nombre.<span class="code-var">toUpperCase</span>())
                }
              </pre>

              <h3>Desestructurar objetos</h3>
              <p>
                En esta clase aprenderemos otra forma de acceder a los atributos
                de los objetos que es la desestructuración de estos. Para no
                duplicar las variables introducir el nombre de la variable como
                parámetro de la segunda variable.
              </p>
              <pre class="code">

                <span class="code-var">var</span> nombre = persona.nombre

                <span class="code-comment">Lo anterior se puede escribir así</span>
                <span class="code-var">var</span> {nombre} = persona
              </pre>
              <p>
                Lo que se hace es crear una variable nombre que va a tomar el
                valor del atributo nombre del objeto persona.
              </p>
              <p>
                También se puede crear un nuevo objeto dentro de los parametros
                de la función.
              </p>
              <pre class="code">

                <span class="code-function">imprimirNombreEnMayusculas</span>({nombre: <span class="code-text">'pepito'</span>})
              </pre>
              <div class="note">
                <p>Acceder a los atributos de los objetos desestructuración.</p>
              </div>
              <h3>Parámetros como referencia o como valor</h3>
              <p>
                Javascript se comporta de manera distinta cuando le pasamos un
                objeto como parámetro. Cuando los objetos se pasan como una
                referencia, estos se modifican fuera de la función. Para
                solucionar esto se puede crear un objeto diferente. Esto lo
                podemos hacer colocando tres puntos antes del nombre. Ej
                …persona.
              </p>
              <p>
                Cuando a una función le pasamos un objeto como parámetro y
                dentro de esa función se modifica algún atributo del objeto, ese
                objeto se verá modificado en todo el documento. Si se quiere
                evitar esto se puede retornar un objeto nuevo con los mismos
                atributos que el original, pero a la vez con la modificación que
                se requería, es decir, el original quedara igual sin
                modificación y el nuevo será el que tenga el cambio.
              </p>
              <pre class="code">

                <span class="code-var">function</span> <span class="code-function">birthday</span>(persona){
                  <span class="code-sym">return</span>{
                    ...persona,
                    edad : persona.edad + 1
                  }
                }

                <span class="code-function">birthday</span>(carlos) <span class="code-comment">//{nombre: 'Carlos', apellido : 'Zabala', edad : 23}</span>
                carlos <span class="code-comment">//El objeto original no fue modificado {nombre : 'Carlos', apellido : 'Zabala', edad:22}</span>
              </pre>
            </article>
            <article class="course-class__section" id="compare">
              <h2 class="course-class__section--title">
                Comparaciones en JavaScript
              </h2>
              <p>
                Existen varias maneras de comparar variables u objetos dentro de
                javascript. En el primer ejemplo le asignamos a X un valor
                numérico y a Y un string. Para poder compararlos debemos agregar
                dos signos de igual (==). Esto los convierte al mismo tipo de
                valor y permite que se puedan comparar. Cuando realizamos
                operaciones es recomendable usar tres símbolos de igual (===).
                Esto permite que JavasScript no iguale las variables que son de
                distinto tipo. Te recomendamos que uses el triple igual siempre
                que estés comparando variables.
              </p>
              <p>
                Existen cinco tipos de datos que son primitivos:
              </p>
              <ul>
                <li>Boolean.</li>
                <li>Null.</li>
                <li>Undefined.</li>
                <li>Number.</li>
                <li>String.</li>
              </ul>
            </article>
            <article class="course-class__section" id="conditional">
              <h2 class="course-class__section--title">Condicionales</h2>
              <p>
                Las estructuras de control nos permiten decidir el flujo de
                nuestro código. Empezaremos con los condicionales. Los
                condicionales nos permiten decidir si un código se ejecuta o no.
                También introducimos un nuevo tipo de datos primitivos: el
                booleano, que determina si un valor es falso o verdadero.
                Mediante un condicional (if) decidiremos si se ejecuta una parte
                de nuestro código cuando se cumpla o no cierta condición.
              </p>
              <pre class="code">

                <span class="code-var">function</span> <span class="code-function">esMayorDeEdad</span>(persona){
                  <span class="code-sym">if</span>(persona.edad >= 18){
                    console.<span class="code-var">log</span>(<span class="code-text">`${persona.nombre} es mayor de edad`</span>)
                  }
                  <span class="code-sym">else</span>{
                    console.<span class="code-var">log</span>(<span class="code-text">`${persona.nombre} es menor de edad`</span>)
                  }
                }
              </pre>
              <p>Lo anterior se puede simplificar a lo siguiente.</p>
              <pre class="code">

                <span class="code-var">function</span> <span class="code-function">esMayorDeEdad</span>({nombre, edad}){
                  console.<span class="code-var">log</span>(<span class="code-text">`${nombre} es ${edad >= 18 ? 'mayor':'menor'} de edad`</span>)
                }
              </pre>
            </article>
            <article class="course-class__section" id="arrow-function">
              <h2 class="course-class__section--title">Arrow functions</h2>
              <p>
                Permiten una nomenclatura más corta para escribir expresiones de
                funciones. Este tipo de funciones deben definirse antes de ser
                utilizadas. Al escribir las Arrow Functions no es necesario
                escribir la palabra function, la palabra return, ni las llaves.
              </p>
              <pre class="code">

              <span class="code-var">function</span> <span class="code-function">esMayorEdad</span>(persona){
                <span class="code-sym">return</span> persona.edad >= MAYORIA_DE_EDAD
              }

              <span class="code-comment">//La funcion anterior se puede guardar en una variable</span>
              <span class="code-var">const</span> esMayorEdad = <span class="code-var">function</span>(persona){
                <span class="code-sym">return</span> persona.edad >= MAYORIA_DE_EDAD
              }
            </pre>
              <p>Ahora usando arrow functions</p>
              <pre class="code">

              <span class="code-var">const</span> esMayorEdad = persona <span class="code-sym">=></span> persona.edad >= MAYORIA_DE_EDAD

              <span class="code-comment">//Otro ejemplo</span>
              <span class="code-var">const</span> permitirAcceso = ({edad}) <span class="code-sym">=></span> esMayorEdad({edad}) <span class="code-sym">?</span> console.<span class="code-var">log</span>(<span class="code-text">'NICE'</span>) <span class="code-sym">:</span> console.<span class="code-var">log</span>(<span class="code-text">'NO'</span>)
            </pre>
            </article>
            <article class="course-class__section" id="for">
              <h2 class="course-class__section--title">
                Estructuras repetitivas: for
              </h2>
              <p>
                En esta clase estudiaremos una de las estructuras básicas de
                control. El bucle for, se utiliza para repetir una o más
                instrucciones un determinado número de veces. Para escribir un
                bucle for se coloca la palabra for seguida de paréntesis y
                llaves. Ej. for( ){ }. Dentro de los paréntesis irán las
                condiciones para ejecutar el bucle, y dentro las llaves irán las
                instrucciones que se deben repetir.
              </p>
            </article>
            <article class="course-class__section" id="while">
              <h2 class="course-class__section--title">
                Estructuras repetitivas: while
              </h2>
              <p>
                While se ejecuta únicamente mientras la condición que se está
                evaluando es verdadera. En ocasiones nuestro código puede fallar
                por errores de syntaxis o errores lógicos. En caso de que
                quieras verificar tu código, debes utilizar un debugger. El
                código se detiene cada vez que lee esta palabra.
              </p>
            </article>
            <article class="course-class__section" id="do-while">
              <h2 class="course-class__section--title">
                Estructuras repetitivas: do-while
              </h2>
              <p>
                Otra estructura repetitiva es el do-while. A diferencia de la
                instrucción while, un bucle do…while se ejecuta una vez antes de
                que se evalúe la expresión condicional.
              </p>
            </article>
            <article class="course-class__section" id="switch">
              <h2 class="course-class__section--title">
                Condicional múltiple: switch
              </h2>
              <p>
                Una última estructura de control se llama switch. Switch se
                utiliza para realizar diferentes acciones basadas en múltiples
                condiciones. <br />
                <span class="t-bold"
                  >Prompt, muestra un cuadro de mensaje que le pide al usuario
                  que ingrese algúna información.</span
                >
                <br />
                Break, sirve para que el browser se salte un bucle.
              </p>
              <pre class="code">

                <span class="code-var">var</span> signo = <span class="code-var">prompt</span>(<span class="code-text">'Ingrese su signo zodiacal'</span>)

                <span class="code-var">const</span> HOROSCOPOS = [
                  <span class="code-text">'21 marzo - 19 abril'</span>,
                  <span class="code-text">'20 abril - 20 mayo'</span>,
                  ...
                ]

                <span class="code-var">var</span>  <span class="code-function">calcularSigno</span> = (signo) <span class="code-sym">=></span> {
                  <span class="code-sym">switch</span> (signo.<span class="code-var">toLowerCase</span>()) {
                    <span class="code-sym">case</span> <span class="code-text">'aries'</span>:
                      console.<span class="code-var">log</span>(HOROSCOPOS[0])
                      <span class="code-sym">break</span>
                    <span class="code-sym">case</span> <span class="code-text">'tauro'</span>:
                      console.<span class="code-var">log</span>(HOROSCOPOS[1])
                      <span class="code-sym">break</span>
                    <span class="code-sym">case</span> <span class="code-text">'geminis'</span>:
                    <span class="code-sym">case</span> <span class="code-text">'géminis'</span>:
                      console.<span class="code-var">log</span>(HOROSCOPOS[2])
                      <span class="code-sym">break</span>    
                    <span class="code-sym">default</span> : console.<span class="code-var">log</span>(<span class="code-text">'Signo incorrecto'</span>); <span class="code-sym">break</span>;
                  }
                }

                <span class="code-function">calcularSigno</span>(signo)
              </pre>
            </article>
            <article class="course-class__section" id="array">
              <h2 class="course-class__section--title">
                Introducción a arrays
              </h2>
              <p>
                Los arrays son estructuras que nos permiten organizar elementos
                dentro de una colección. Estos elementos pueden ser números,
                strings, booleanos, objetos, etc.
              </p>
              <p>
                Para indicar que algo es un array se utiliza el símbolo []. En
                js se permiten mezclar diferentes tipos de datos en un array.
              </p>
              <h3>Filtrar un array</h3>
              <p>
                Para filtrar siempre necesitamos establecer una condición. El
                método <span class="t-bold">filter()</span> crea una nueva
                matriz con todos los elementos que pasan la prueba implementada
                por la función proporcionada. Recuerda que si no hay elementos
                que pasen la prueba, filter devuelve un array vacío.
              </p>
              <pre class="code">

                <span class="code-var">const</span> <span class="code-function">sonAltas</span> = ({altura}) <span class="code-sym">=></span> altura >= 1.80 
                <span class="code-var">const</span> <span class="code-function">sonBajas</span> = ({altura}) <span class="code-sym">=></span> altura < 1.80

                <span class="code-comment">//Array de personas</span>
                <span class="code-var">var</span> personas = [sacha, alan, martin, dario, vicky, paula]

                <span class="code-var">var</span> personasAltas = personas.<span class="code-var t-bold">filter</span>(sonAltas)
                <span class="code-var">var</span> personasBajas = personas.<span class="code-var t-bold">filter</span>(sonBajas)
              </pre>
              <div class="note">
                <p>
                  Para filtrar se necesitan dos cosas un array y una condición y
                  la condición puede ser una función. Para filtrar en un array,
                  se utiliza el método <span class="t-bold">filter</span>, y
                  recibe como parámetros una condición. <br /><br />
                  <span class="t-bold"
                    >var filtro = array.filter(condición)</span
                  >
                  <br /><br />
                  Filter lo que hace es ir filtrando, recorriendo e iterando
                  cada elemento del array.
                </p>
              </div>
              <h3>Transformar un array</h3>
              <p>
                El método <span class="t-bold">map()</span> itera sobre los
                elementos de un array en el orden de inserción y devuelve array
                nuevo con los elementos modificados.
              </p>
              <pre class="code">

                <span class="code-comment">// esta funcion modificaria el array original</span>
                <span class="code-var">const</span> <span class="code-function">convertirCm</span> = persona => {
                  persona.altura *= 100
                  <span class="code-sym">return</span> persona
                }

                <span class="code-comment">// esta funcion no modifica el original, devuelve uno nuevo</span>
                <span class="code-var">const</span> <span class="code-function">convertirCm</span> = persona => ({
                  <span class="code-sym">...</span>persona,
                  altura: persona.altura * 100
                })

                <span class="code-comment">// otra forma de escribirlo</span>
                <span class="code-var">const</span> <span class="code-function">convertirCm</span> = persona =>{
                  <span class="code-comment">// el return {} se usa cuando se devuelve un array nuevo ...</span>
                  <span class="code-sym">return</span> {
                    <span class="code-sym">...</span>persona,
                    altura : persona.altura * 100
                  }
                }
                
                <span class="code-comment">//Usando el método map</span>
                <span class="code-var">var</span> personasCm = personas.<span class="code-var t-bold">map</span>(<span class="code-function">convertirCms</span>)
              </pre>
              <div class="note">
                <p>
                  A diferencia de filter, la función Map nos devuelve un
                  <span class="t-bold"
                    >nuevo array que modifica a todos los elementos del array
                    original</span
                  >.
                </p>
                <p>
                  Para mostrar en la consola una lista de arrays tabulados, se
                  puede usar console.<span class="t-bold">table</span>(array).
                </p>
              </div>
              <h3>Reducir un array a un valor</h3>
              <p>
                El método reduce() nos permite reducir, mediante una función que
                se aplica a cada uno de los elemento del array, todos los
                elementos de dicho array, a un valor único.
              </p>
            </article>
            <article class="course-class__section" id="class">
              <h2 class="course-class__section--title">Clases</h2>
              <p>
                Las clases son funciones cuya sintaxis tiene dos componentes:
              </p>
              <ul>
                <li>expresiones</li>
                <li>declaraciones</li>
              </ul>
              <p>
                Dentro de una función, el valor de this depende de cómo es
                llamada ésta.
              </p>
              <ul>
                <li>
                  Hablar de objetos en javascript es hablar de prototipos.
                </li>
                <li>
                  this hace referencia al nuevo objeto que se acaba de crear.
                </li>
                <li>
                  la función que define al prototipo retorna implícitamente
                  this, es decir retorna el nuevo objeto que se creo.
                </li>
                <li>
                  La palabra reservada new se utiliza para crear un nuevo objeto
                  con el prototipo indicado.
                </li>
              </ul>
              <pre class="code">

                <span class="code-var">function</span> <span class="code-function">Persona</span>(nombre, apellido, altura){
                  <span class="code-var">this</span>.nombre = nombre
                  <span class="code-var">this</span>.apellido = apellido
                  <span class="code-var">this</span>.altura = altura
                }
                
                Persona.<span class="code-var">prototype</span>.saludar = <span class="code-var">function</span>(){
                  console.<span class="code-var">log</span>(<span class="code-text">`Hola, me llamo ${this.nombre} ${this.apellido} y ${this.esAlto()}`</span>)
                }
                
                Persona.<span class="code-var">prototype</span>.esAlto = <span class="code-var">function</span>(){
                   console.<span class="code-var">log</span>(<span class="code-text">`${this.nombre} ${this.altura >= 1.8 ? 'es': 'no es'} una persona alta`</span>)
                }
              </pre>
              <h3>Modificando un prototipo</h3>
              <p>
                JavaScript funciona con una estructura orientada a objetos y
                cada objeto tiene una propiedad privada que mantiene un enlace a
                otro objeto llamado prototipo.
              </p>
              <p>
                Es de mucha importancia
                <span class="t-bold"
                  >donde colocamos las funciones que va a tener el
                  prototipo</span
                >. Estos se deben de colocar juntos, ya que con ellos se va
                creando <span class="t-bold">el prototipo del objeto</span>, y
                deseamos que tenga juntas todas sus funciones. Por ello
                <span class="t-bold"
                  >definimos los prototipos arriba, y los utilizamos a lo largo
                  del código</span
                >. NOTA: Cuando tenemos un error en JS, éste no se sigue
                ejecutando, se corta ahí la ejecución del código.
              </p>
              <h3>La verdad oculta sobre las clases en JavaScript</h3>
              <p>
                Los objetos en JavaScript son "contenedores" dinámicos de
                propiedades. Estos objetos poseen un enlace a un objeto
                prototipo. Cuando intentamos acceder a la propiedad de un
                objeto, la propiedad no sólo se busca en el propio objeto sino
                también en el prototipo del objeto, en el prototipo del
                prototipo, y así sucesivamente hasta que se encuentre una
                propiedad que coincida con el nombre o se alcance el final de la
                cadena de prototipos.
              </p>
              <div class="note">
                <p>
                  En js las clases no existen son prototipos, son objetos que
                  les vamos agregando métodos que son funciones.
                </p>
              </div>
              <p>
                Para simular la "herencia" se debe crear una función propia.
              </p>
              <pre class="code">

                <span class="code-comment">//hacer herencia de prototipos</span>
                <span class="code-var">function</span> <span class="code-function">heredaDe</span>(prototipoHijo, prototipoPadre){
                  <span class="code-var">var</span> fn = <span class="code-var">function</span>(){}
                  fn.prototype = prototipoPadre.prototype
                  prototipoHijo.prototype = <span class="code-sym">new</span> fn
                  prototipoHijo.prototype.constructor = prototipoHijo
                }

                <span class="code-function">heredaDe</span>(Desarrollador, Persona)
              </pre>
            </article>
            <article class="course-class__section" id="this">
              <h2 class="course-class__section--title">
                El contexto de las funciones: quién es this
              </h2>
              <p>
                El error del contexto de this en javascrip es uno de los errores
                más comunes. Recuerda que dentro de la arrow function, this está
                haciendo referencia al espacio global, a windows.
              </p>
              <div class="note">
                <p>
                  <span class="t-bold">Window</span> es el objeto global dentro
                  del navegador. <br />
                  Cuando this no es lo que esperamos, este es el principal error
                  en JS. <br />
                  En las <span class="t-bold">Arrow functions</span>, se asigna
                  la función , pero cambia el this dentro de la función , ya que
                  trata de tomar el this global, es decir, el que está fuera de
                  la Arrow function. Para
                  <span class="t-bold">comprobarlo en consola</span>: <br />
                  this === window.
                </p>
              </div>
              <p>
                <span class="t-bold">¿Para qué sirve el debugger?</span> Para
                solventar errores ("bugs" como dicen los programadores)
                deteniendo tu programa en la línea de código donde coloques el
                debugger y dándote herramientas para ver qué sucede.
              </p>
            </article>
            <article class="course-class__section" id="class-ecma">
              <h2 class="course-class__section--title">Clases en ECMAScript</h2>
              <p>
                Las clases de JavaScript son introducidas en el ECMAScript 2015
                y son una mejora en la sintaxis sobre la herencia basada en
                prototipos de JavaScript. <br />
                La palabra clave extends se usa en declaraciones de clase o
                expresiones de clase para crear una clase que es hija de otra
                clase. <br />
                El método constructor es un método especial para crear e
                inicializar un objeto creado a partir de una clase.
              </p>
              <pre class="code">

                <span class="code-var">class</span> <span class="code-function">Persona</span>{
                  <span class="code-var">constructor</span>(nombre, apellido, altura){
                    <span class="code-sym">this</span>.nombre = nombre
                    <span class="code-sym">this</span>.apellido = apellido
                    <span class="code-sym">this</span>.altura = altura
                  }

                  <span class="code-var">saludar</span>(){
                    console.<span class="code-var">log</span>(<span class="code-text">`Hola, me llamo ${this.nombre} ${this.apellido}`</span>)
                  }

                  <span class="code-var">soyAlto</span>(){

                  }
                }
              </pre>
            </article>
            <article class="course-class__section" id="async">
              <h2 class="course-class__section--title">
                Cómo funciona el asincronismo en JavaScript
              </h2>
              <p>
                JavaScript sólo puede hacer una cosa a la vez, sin embargo; es
                capaz de delegar la ejecución de ciertas funciones a otros
                procesos. Este modelo de concurrencia se llama EventLoop.
                JavaScript delega en el navegador ciertas tareas y les asocia
                funciones que deberán ser ejecutadas al ser completadas. Estas
                funciones se llaman callbacks, y una vez que el navegador ha
                regresado con la respuesta, el callback asociado pasa a la cola
                de tareas para ser ejecutado una vez que JavaScript haya
                terminado todas las instrucciones que están en la pila de
                ejecución. Si se acumulan funciones en la cola de tareas y
                JavaScript se encuentra ejecutando procesos muy pesados, el
                EventLoop quedará bloqueado y esas funciones pudieran tardar
                demasiado en ejecutarse.
              </p>
              <div class="note">
                <p>
                  Js no es multitarea, pero puede delegar funciones -> a eso se
                  le llama event loop.
                </p>
              </div>
              <pre class="code">

                <span class="code-var">while</span>(<span class="code-sym">true</span>){ console.<span class="code-var">warn</span>(<span class="code-text">' NO VOY A BLOQUEAR EL EVENTLOOP'</span>) }
              </pre>
            </article>
            <article class="course-class__section" id="time-javascript">
              <h2 class="course-class__section--title">
                Cómo funciona el tiempo en JavaScript
              </h2>
              <p>
                En principio, cualquier tarea que se haya delegado al navegador
                a través de un callback, deberá esperar hasta que todas las
                instrucciones del programa principal se hayan ejecutado. Por
                esta razón el tiempo de espera definido en funciones como
                setTimeout, no garantizan que el callback se ejcute en ese
                tiempo exactamente, sino en cualquier momento a partir de allí,
                sólo cuando la cola de tareas se haya vaciado.
              </p>
            </article>
            <article class="course-class__section" id="callbacks">
              <h2 class="course-class__section--title">Callbacks</h2>
              <p>
                Un callback es una función que se pasa a otra función como un
                argumento. Esta función se invoca, después, dentro de la función
                externa para completar alguna acción.
              </p>
              <p>
                para hacer request en jquery llamar al metodo $.get acepta
                varios parametros :
              </p>
              <ol>
                <li>URL</li>
                <li>Indicar que el request es a una página externa</li>
                <li>
                  Callback que se ejecutara en un futuro pero que no sabemos
                  cuando
                </li>
              </ol>
              <pre class="code">

                <span class="code-comment">//URL a acceder</span>
                <span class="code-var">const</span> API_URL = <span class="code-text">'https://swapi.co/api/'</span>
                <span class="code-var">const</span> PEOPLE_URL = <span class="code-text">'people/:id'</span>

                <span class="code-var">const</span> LUKE_URL = <span class="code-text">`${API_URL}${PEOPLE_URL.replace(':id', 1)}`</span>
                <span class="code-var">const</span> OPTS = {crossDomain : <span class="code-sym">true</span>}

                <span class="code-comment">//Función callback</span>
                <span class="code-var">const</span> <span class="code-function">onPeopleResponse</span> = <span class="code-var">function</span>(person){
                  console.<span class="code-var">log</span>(<span class="code-text">`Hola soy ${person.name}`</span>)
                }

                $.get(LUKE_URL, OPTS, <span class="code-function">onPeopleResponse</span>)
              </pre>
              <h3>Manejando el Orden y el Asincronismo en JavaScript</h3>
              <p>
                Una manera de asegurar que se respete la secuencia en que hemos
                realizado múltiples tareas es utilizando callbacks, con lo que
                se ejecutará luego, en cada llamada. Lo importante es que el
                llamado al callback se haga a través de una función anónima. Sin
                embargo, al hacerlo de esta manera generamos una situación poco
                deseada llamada CallbackHell.
              </p>
              <pre class="code">

              <span class="code-comment">//callback hell</span>
               <span class="code-function">obtenerPersonaje</span>(1, function () {
                <span class="code-function">obtenerPersonaje</span>(2, function () {
                  <span class="code-function">obtenerPersonaje</span>(3, function () {
                    <span class="code-function">obtenerPersonaje</span>(4, function () {
                      <span class="code-function">obtenerPersonaje</span>(5, function () {
                        <span class="code-function">obtenerPersonaje</span>(6, function () {
                          <span class="code-function">obtenerPersonaje</span>(7, function () {
                            <span class="code-function">obtenerPersonaje</span>(8)
                          })
                        })
                      })
                    })
                  })
                })
              })
              </pre>
            </article>
            <article class="course-class__section" id="promise">
              <h2 class="course-class__section--title">Promesas</h2>
              <p>
                Son valores que aún no conocemos. Las promesas tienen tre
                estados:
              </p>
              <ul>
                <li>pending</li>
                <li>fullfilled</li>
                <li>reject</li>
              </ul>
              <p>Las promesas se invocan de la siguiente forma:</p>
              <pre class="code">

                <span class="code-sym">new</span> Promise((resolve, reject) <span class="code-sym">=></span> {
                  <span class="code-comment">//llamado asíncrono</span>
                  <span class="code-sym">if</span>(todoOk){
                    <span class="code-comment">//se ejecutó el llamado exitosamente</span>
                    <span class="code-var">resolve</span>()
                  }
                  <span class="code-sym">else</span>{
                    <span class="code-comment">hubo un error en el llamado</span>
                    <span class="code-var">reject</span>()
                  }
                })
              </pre>
              <p>Pensemos las promesas como valores que aún no conocemos.</p>
              <pre class="code">

                <span class="code-var">function</span> <span class="code-function">obtenerPersonaje</span>(id) {
                  <span class="code-sym">return new</span> Promise(<span class="code-var">function</span>(resolve, reject){
                    <span class="code-var">const</span> URL = <span class="code-text">`${API_URL}${PEOPLE_URL.replace(':id', id)}`</span>
                    $
                    .<span class="code-function">get</span>(URL, OPTS, <span class="code-var">function</span>(data){
                      <span class="code-var">resolve</span>(data)
                    })
                    .<span class="code-function">fail</span>(<span class="code-var">function</span>(){
                      <span class="code-var">reject</span>(id)
                    })
                  })
                }

                <span class="code-function">obtenerPersonaje</span>(1)
                .<span class="code-var">then</span>(<span class="code-var">function</span>(personaje){
                  console.<span class="code-var">log</span>(<span class="code-text">`El personaje 1 es ${personaje.name}`</span>)
                })
                .<span class="code-var">catch</span>(error => console.<span class="code-var">log</span>(<span class="code-text">`error`</span>))
              </pre>
              <h3>Promesas encadenadas</h3>
              <p>
                A diferencia de los callbacks en el CallbackHell, que terminan
                estando anidados unos dentro de otros, cuando se usan Promesas
                la ejecución de las llamadas no se hacen de manera anidada sino
                de manera encadenada, al mismo nivel una debajo de la otra, lo
                que hace que el código sea mucho más legible y mantenible.
              </p>
              <h3>Múltiples promesas en paralelo</h3>
              <p>
                Para hacer el llamado a múltiples promesas, nos apoyamos en un
                array de ids con el que luego construimos otro arreglo de
                Promesas, que pasaremos como parámetro a Promise.all(
                arregloDePromesas ), con las promesas podemos encadenar llamadas
                en paralelo, algo que no es posible usando callbacks.
              </p>
              <pre class="code">

                <span class="code-comment">//crear array de ids</span>
                <span class="code-var">var</span> ids = [1, 2, 3, 4, 5, 6, 7]

                <span class="code-comment">//crear un array de promesas, con base al array IDS llamar al metodo obtener personajes</span>
                <span class="code-var">var</span> promesas = ids.<span class="code-var">map</span>(id <span class="code-sym">=></span> <span class="code-function">obtenerPersonaje</span>(id))

                <span class="code-var">Promise</span> 
                  .<span class="code-var">all</span> (promesas)
                  .<span class="code-var">then</span> (<span class="code-var">function</span> (personajes){
                    <span class="code-sym">form</span> (let i = 0; i < personajes.length;i++){
                      console.<span class="code-var">log</span> (<span class="code-text">`El personaje ${i+1} es: ${personajes[i].name}`</span>)
                    }
                  })
                  .<span class="code-var">catch</span>(onError)
              </pre>
            </article>
            <article class="course-class__section" id="async-await">
              <h2 class="course-class__section--title">
                Async-await: lo último en asincronismo
              </h2>
              <p>
                Async-await es la manera más simple y clara de realizar tareas
                asíncronas. Await detiene la ejecución del programa hasta que
                todas las promesas sean resueltas. Para poder utilizar esta
                forma, hay que colocar async antes de la definición de la
                función, y encerrar el llamado a Promises.all() dentro de un
                bloque try … catch.
              </p>
              <pre class="code">

                <span class="code-sym">async</span> <span class="code-var">function</span> <span class="code-function">obtenerPersonaje</span>(){
                  <span class="code-comment">//crear array de ids</span>
                  <span class="code-var">var</span> ids = [1, 2, 3, 4, 5, 6, 7]
                
                  <span class="code-comment">//crear un array de promesas, con base al array IDS llamar al metodo obtener personajes</span>
                  <span class="code-var">var</span> promesas = ids.<span class="code-var">map</span>(id <span class="code-sym">=></span> <span class="code-function">obtenerPersonaje</span>(id))
                
                  <span class="code-sym">try</span> {
                    var personajes = <span class="code-sym">await</span> Promise.<span class="code-var">all</span>(promesas)
                    console.<span class="code-var">log</span>(personajes)
                  } <span class="code-sym">catch</span> (id) {
                    <span class="code-function">onError</span>(id)
                  }
                }
              </pre>
            </article>
            <article class="course-class__section" id="context-function">
              <h2 class="course-class__section--title">
                Cambiando de contexto al llamar a una función
              </h2>
              <p>
                El contexto (o alcance) de una función es por lo general,
                window. Así que, en ciertos casos, cuando intentamos referirnos
                a this en alguna parte del código, es posible que tengamos un
                comportamiento inesperado, porque el contexto quizás no sea el
                que esperamos. <br> Existen al menos tres maneras de cambiar el
                contexto de una función.
              </p>
              <ul>
                <li>Usando el método .bind, enviamos la referencia a la función sin ejecutarla, pasando el contexto como parámetro.</li>
                <li>Usando el método .call, ejecutamos inmediatamente la función con el contexto indicado.s</li>
                <li>Usando el método .apply, es similar a .call pero los parámetros adicionales se pasan como un arreglo de valores</li>
              </ul>
              <pre class="code">

                <span class="code-var">constructor</span>(){
                  <span class="code-sym">this</span>.<span class="code-function">handleClick</span> = <span class="code-sym">this</span>.<span class="code-function">handleClick</span>.<span class="code-var">bind</span>(this)
                }
              </pre>
            </article>
          </div>
        </section>
      </div>
    </div>
    <script>
      const $menu = document.getElementById("btn-menu");
      const $courseMenu = document.getElementById("course-class__left");

      $menu.addEventListener("click", handleClick);

      function handleClick() {
        $courseMenu.classList.toggle("is-active");
        $menu.classList.toggle("is-active");

        if ($menu.classList.contains("icon-menu")) {
          $menu.classList.remove("icon-menu");
          $menu.classList.add("icon-close");
        } else {
          $menu.classList.remove("icon-close");
          $menu.classList.add("icon-menu");
        }
      }
    </script>
  </body>
</html>
