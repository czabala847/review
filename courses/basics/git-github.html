<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Curso Git & GitHub</title>
    <link rel="icon" href="../../images/favicon.png" type="img/text" />
    <link
      href="https://fonts.googleapis.com/css?family=Pacifico|Source+Sans+Pro&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../../css/styles.css" />
    <link rel="stylesheet" href="../../fonts/style.css" />
  </head>
  <body>
    <div class="app">
      <div class="app-react-basico">
        <header class="header">
          <div class="container-general">
            <nav class="header-menu">
              <ul class="header-menu__list menu-left">
                <li class="header-menu__list--item">
                  <a class="link" href="../../index.html">Inicio</a>
                </li>
                <li class="header-menu__list--item">
                  <a class="link" href="../../index.html##courses">Carreras</a>
                </li>
              </ul>
              <figure class="header-menu__logo">
                <a href="../../index.html"
                  ><img
                    class="header-menu__logo--img"
                    src="../../images/logo_white.png"
                    alt="logo carlos zabala"
                /></a>
              </figure>
              <ul class="header-menu__list menu-right">
                <li class="header-menu__list--item">
                  <a class="link" href="">Me</a>
                </li>
                <li class="header-menu__list--item">
                  <a class="link" href="">Contacto</a>
                </li>
              </ul>
            </nav>
          </div>
        </header>
        <section class="hero-course">
          <div class="container-general">
            <h1 class="hero-course__title">Curso de Git y Github</h1>
            <p class="hero-course__description">
              Este curso se enseñara para qué sirve Git, cómo usarlo, cómo
              mejora nuestra productividad y cómo sacarle el mayor provecho.
              <br />
              Git es un software de control de versiones diseñado por Linus
              Torvalds, pensando en la eficiencia y la confiabilidad del
              mantenimiento de versiones de aplicaciones cuando estas tienen un
              gran número de archivos de código fuente. En su lugar GitHub es
              una forja para alojar proyectos utilizando el sistema de control
              de versiones Git. GitHub sería la red social de código para los
              programadores, tu propio curriculum vitae.
            </p>
            <div class="hero-course__buttons">
              <a
                target="_blank"
                href="https://platzi.com/clases/git-github/"
                class="btn btn--primary"
                >Curso platzi</a
              >
            </div>
          </div>
        </section>
        <section class="course-class">
          <div class="course-class__left" id="course-class__left">
            <div class="course-class__left--container">
              <nav class="course-class__menu">
                <ul>
                  <li>
                    <a class="link course-class__menu--a" href="#introduction"
                      >Sistema de control de versiones</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#install"
                      >Instalar Git</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#console"
                      >Línea de comandos</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#ciclo"
                      >Ciclos de trabajo Git</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#branch"
                      >Ramas en Git</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#user-git"
                      >Git config</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#show-diff"
                      >Cambios en un archivo</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#remote-repo"
                      >Repositorio remoto</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#git-branch"
                      >Git Branch</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#git-merge"
                      >Git Merge</a
                    >
                  </li>
                  <li>
                    <a class="link course-class__menu--a" href="#conflict-merge"
                      >Git Merge conflictos</a
                    >
                  </li>
                </ul>
              </nav>
            </div>
          </div>
          <div class="course-class__content">
            <i class="icon-menu icon course-class__icon-menu" id="btn-menu"></i>
            <article class="course-class__section" id="introduction">
              <h2 class="course-class__section--title">
                ¿Por qué usar un sistema de control de versiones como Git?
              </h2>
              <div class="course-class__section--content">
                <p>
                  Un sistema de control de versiones como Git nos ayuda a
                  guardar el historial de cambios y crecimiento de los archivos
                  de nuestro proyecto.
                </p>
                <p>
                  En realidad, los cambios y diferencias entre las versiones de
                  nuestros proyecto pueden tener similitudes, algunas veces los
                  cambios pueden ser solo una palabra o una parte específica de
                  un archivo específico. Git está optimizado para guardar todos
                  estos cambios de forma atómica e incremental, o sea, aplicando
                  cambios sobre los últimos cambios, estos sobre los cambios
                  anteriores y así hasta el inicio de nuestro proyecto.
                </p>
                <ul>
                  <li>
                    El comando para iniciar nuestro repositorio, o sea,
                    indicarle a Git que queremos usar su sistema de control de
                    versiones en nuestro proyecto, es
                    <span class="t-bold">git init</span>.
                  </li>
                  <li>
                    El comando para que nuestro repositorio sepa de la
                    existencia de un archivo o sus últimos cambios es
                    <span class="t-bold">git add</span>. Este comando no
                    almacena las actualizaciones de forma definitiva, solo las
                    guarda en algo que conocemos como "Staging Area".
                  </li>
                  <li>
                    El comando para almacenar definitivamente todos los cambios
                    que por ahora viven en el staging area es
                    <span class="t-bold">git commit</span>. También podemos
                    guardar un mensaje para recordar muy bien qué cambios
                    hicimos en este commit con el argumento
                    <span class="t-bold">-m "Mensaje del commit"</span>.
                  </li>
                  <li>
                    Por último, si queremos mandar nuestros commits a un
                    servidor remoto, un lugar donde todos podamos conectar
                    nuestros proyectos, usamos el comando
                    <span class="t-bold">git push</span>.
                  </li>
                </ul>
              </div>
            </article>
            <article class="course-class__section" id="install">
              <h2 class="course-class__section--title">
                Instalando Git y GitBash en Windows
              </h2>
              <div class="course-class__section--content">
                <p>
                  Windows y Linux comandos diferentes, graban el enter de formas
                  diferentes y tienen muchas otras diferencias. Cuando instales
                  Git Bash en Windows debes elegir si prefieres trabajar con la
                  forma de Windows o la forma de UNIX (Linux y Mac).
                </p>
                <p>
                  Ten en cuenta que, normalmente, los entornos de desarrollo
                  profesionales tienen personas que usan sistemas operativos
                  diferentes. Esto significa que, si todos podemos usar los
                  mismos comandos, el trabajo resultará más fácil para todos en
                  el equipo.
                </p>
                <p>
                  Los comandos de UNIX son los más comunes entre los equipos de
                  desarrollo. Así que, a menos que trabajes con tecnologías
                  nativas de Microsoft (por ejemplo, .NET), la recomendación es
                  que elijas la opción de la terminal tipo UNIX para obtener una
                  mejor compatibilidad con todo tu equipo.
                </p>
                <a
                  class="btn btn--blue"
                  href="https://git-scm.com/"
                  target="_blank"
                  >Descargar Git</a
                >
              </div>
            </article>
            <article class="course-class__section" id="console">
              <h2 class="course-class__section--title">Línea de comandos</h2>
              <div class="course-class__section--content">
                <p>
                  <span class="t-bold">Diferencias</span> entre la estructura de
                  archivos de Windows, Mac o Linux.
                </p>
                <ul>
                  <li>
                    La ruta principal en Windows es C:\, en UNIX es solo /.
                  </li>
                  <li>
                    Windows no hace diferencia entre mayúsculas y minúsculas
                    pero UNIX sí.
                  </li>
                </ul>
                <h3>Comandos básicos en la terminal</h3>
                <ul>
                  <li>
                    <span class="t-bold">pwd:</span> Nos muestra la ruta de
                    carpetas en la que te encuentras ahora mismo.
                  </li>
                  <li>
                    <span class="t-bold">mkdir:</span> Nos permite crear
                    carpetas.
                    <pre class="code">

                      mkdir nombre-carpeta
                    </pre>
                  </li>
                  <li>
                    <span class="t-bold">touch:</span> Nos permite crear
                    archivos.
                    <pre class="code">

                      touch archivo.txt
                    </pre>
                  </li>
                  <li>
                    <span class="t-bold">rm:</span> Nos permite borrar un
                    archivo o carpeta.
                  </li>
                  <li>
                    <span class="t-bold">cat:</span> Ver el contenido de un
                    archivo.
                  </li>
                  <li>
                    <span class="t-bold">ls:</span>
                    Nos permite cambiar ver los archivos de la carpeta donde
                    estamos ahora mismo. Podemos usar uno o más argumentos para
                    ver más información sobre estos archivos (los argumentos
                    pueden ser -- + el nombre del argumento o - + una sola letra
                    o shortcut por cada argumento).
                    <ul>
                      <li>
                        <span class="t-bold">ls -a:</span> Mostrar todos los
                        archivos, incluso los ocultos.
                      </li>
                      <li>
                        <span class="t-bold">ls -l:</span> Ver todos los
                        archivos como una lista.
                      </li>
                    </ul>
                  </li>
                  <li>
                    <span class="t-bold">cd:</span> Nos permite navegar entre
                    carpetas.
                  </li>
                  <li>
                    <span class="t-bold">history:</span> Ver los últimos
                    comandos que ejecutamos y un número especial con el que
                    podemos repetir su ejecución.
                  </li>
                  <li>
                    <span class="t-bold">! + número:</span> Ejecutar algún
                    comando con el número que nos muestra el comando history
                    (por ejemplo, !72).
                  </li>
                  <li>
                    <span class="t-bold">clear:</span> Para limpiar la terminal.
                    También podemos usar los atajos de teclado Ctrl + L o
                    Command + L.
                  </li>
                </ul>
              </div>
            </article>
            <article class="course-class__section" id="ciclo">
              <h2 class="course-class__section--title">
                ¿Qué es staging, repositorios y cuál es el ciclo básico de
                trabajo en GitHub?
              </h2>
              <div class="course-class__section--content">
                <p>
                  Para iniciar un repositorio, o sea, activar el sistema de
                  control de versiones de Git en tu proyecto, solo debes
                  ejecutar el comando git init.
                </p>
                <p>
                  Este comando se encargará de dos cosas: primero, crear una
                  carpeta .git donde se guardará toda la base de datos con
                  cambios atómicos de nuestro proyecto; y segundo, crear un área
                  en la memoria RAM, que conocemos como
                  <span class="t-bold">Staging</span>, que guardará
                  temporalmente nuestros archivos (cuando ejecutemos un comando
                  especial para eso) y nos permitirá, más adelante, guardar
                  estos cambios en el repositorio (también con un comando
                  especial).
                </p>
                <h3>Ciclo de vida o estados de los archivos en Git:</h3>
                <p>
                  Cuando trabajamos con Git, nuestros archivos pueden vivir y
                  moverse entre 4 diferentes estados (cuando trabajamos con
                  repositorios remotos pueden ser más estados pero lo
                  estudiaremos más adelante):
                </p>
                <ul>
                  <li>
                    <span class="t-bold">Archivos Untracked:</span> Son archivos
                    que NO viven dentro de Git, solo en el disco duro. Nunca han
                    sido afectados por git add, así que Git no tiene registros
                    de su existencia.
                  </li>
                  <li>
                    <span class="t-bold">Archivos Tracked:</span> Son los
                    archivos que viven dentro de Git, no tienen cambios
                    pendientes y sus últimas actualizaciones han sido guardadas
                    en el repositorio gracias a los comandos git add y git
                    commit.
                  </li>
                  <li>
                    <span class="t-bold">Archivos Unstaged:</span> Entiendelos
                    como archivos "Tracked pero Unstaged". Son archivos que
                    viven dentro de Git pero no han sido afectados por el
                    comando <span class="t-bold">git add</span> ni mucho menos
                    por <span class="t-bold">git commit</span>. Git tiene un
                    registro de estos archivos pero está desactualizado, sus
                    últimas versiones solo están guardadas en el disco duro.
                  </li>
                  <li>
                    <span class="t-bold">Archivos Staged:</span> Son archivos en
                    Staging. Viven dentro de Git y hay registro de ellos porque
                    han sido afectados por el comando
                    <span class="t-bold">git add</span>, aunque no sus últimos
                    cambios. Git ya sabe de la existencia de estos últimos
                    cambios pero todavía no han sido guardados definitivamente
                    en el repositorio porque falta ejecutar el comando
                    <span class="t-bold">git commit</span>.
                  </li>
                </ul>
                <p>
                  Recuerda que hay un caso muy raro donde los archivos tienen
                  dos estados al mismo tiempo: Staged y Untracked. Esto pasa
                  cuando guardas los cambios de un archivo en el área de Staging
                  (con el comando git add) pero, antes de hacer commit para
                  guardar los cambios en el repositorio, haces nuevos cambios
                  que todavía no han sido guardados en el área de Staging (en
                  realidad, todo sigue funcionando igual pero es un poco
                  divertido).
                </p>
                <h3>Comandos para mover archivos entre los estados de Git:</h3>
                <ul>
                  <li>
                    <span class="t-bold">git status:</span> Nos permite ver el
                    estado de todos nuestros archivos y carpetas.
                  </li>
                  <li>
                    <span class="t-bold">git add:</span> Nos ayuda a mover
                    archivos del Untracked o Unstaged al estado Staged. Podemos
                    usar git add nombre-del-archivo-o-carpeta para añadir
                    archivos y carpetas individuales o git add -A para mover
                    todos los archivos de nuestro proyecto (tanto Untrackeds
                    como unstageds).
                  </li>
                  <li>
                    <span class="t-bold">git reset HEAD:</span> Nos ayuda a
                    sacar archivos del estado Staged para devolverlos a su
                    estado anterior. Si los archivos venían de Unstaged, vuelven
                    allí. Y lo mismo se venían de Untracked.
                  </li>
                  <li>
                    <span class="t-bold">git rm:</span> Este comando necesita
                    alguno de los siguientes argumentos para poder ejecutarse
                    correctamente:
                    <ul>
                      <li>
                        <span class="t-bold">git rm --cached:</span> Mueve los
                        archivos que le indiquemos al estado Untracked.
                      </li>
                      <li>
                        <span class="t-bold">git rm --force:</span> Elimina los
                        archivos de Git y del disco duro. Git guarda el registro
                        de la existencia de los archivos, por lo que podremos
                        recuperarlos si es necesario (pero debemos usar comandos
                        más avanzados).
                      </li>
                    </ul>
                  </li>
                </ul>
                <div class="note">
                  <p>
                    Staging: Estado temporal de los archivos que estan en
                    memoria, esperando a pasar al repositorio mediante un
                    commit. Es un lugar antes de enviar los cambios al
                    repositorio.
                  </p>
                </div>
              </div>
            </article>
            <article class="course-class__section" id="branch">
              <h2 class="course-class__section--title">
                ¿Qué es un Branch (rama) y cómo funciona un Merge en Git?
              </h2>
              <div class="course-class__section--content">
                <p>
                  Git es una base de datos muy precisa con todos los cambios y
                  crecimiento que ha tenido nuestro proyecto. Los commits son la
                  única forma de tener un registro de los cambios. Pero las
                  ramas amplifican mucho más el potencial de Git.
                </p>
                <p>
                  <span class="t-bold"
                    >Todos los commits se aplican sobre una rama</span
                  >. Por defecto, siempre empezamos en la rama master (pero
                  puedes cambiarle el nombre si no te gusta) y creamos nuevas
                  ramas, a partir de esta, para crear flujos de trabajo
                  independientes.
                </p>
                <p>
                  Crear una nueva rama se trata de copiar un commit (de
                  cualquier rama), pasarlo a otro lado (a otra rama) y continuar
                  el trabajo de una parte específica de nuestro proyecto sin
                  afectar el flujo de trabajo principal (que continúa en la rama
                  master o la rama principal).
                </p>
                <p>
                  Los equipos de desarrollo tienen un estándar: Todo lo que esté
                  en la rama master va a producción, las nuevas features,
                  características y experimentos van en una rama "development"
                  (para unirse a master cuando estén definitivamente listas) y
                  los issues o errores se solucionan en una rama "hotfix" para
                  unirse a master tan pronto como sea posible.
                </p>
                <p>
                  Crear una nueva rama lo conocemos como
                  <span class="t-bold">Checkout</span>. Unir dos ramas lo
                  conocemos como <span class="t-bold">Merge</span>.
                </p>
                <p>
                  Podemos crear todas las ramas y commits que queramos. De
                  hecho, podemos aprovechar el registro de cambios de Git para
                  crear ramas, traer versiones viejas del código, arreglarlas y
                  combinarlas de nuevo para mejorar el proyecto.
                </p>
                <p>
                  Solo ten en cuenta que combinar estas ramas (sí, hacer
                  "merge") puede generar conflictos. Algunos archivos pueden ser
                  diferentes en ambas ramas. Git es muy inteligente y puede
                  intentar unir estos cambios automáticamente, pero no siempre
                  funciona. En algunos casos, somos nosotros los que debemos
                  resolver estos conflictos "a mano".
                </p>
              </div>
            </article>
            <article class="course-class__section" id="user-git">
              <h2 class="course-class__section--title">
                Comandos para configurar usuarios en Git
              </h2>
              <div class="course-class__section--content">
                <p>
                  Los siguientes comandos serviran para poder hacer
                  configuraciones en git ya sea para modifiar nombre, correo,
                  entre otras cosas a nuestro usuario de git.
                </p>
                <pre class="code">

                  <span class="code-comment">//Muestra todas las configuraciones posibles</span>
                  git config

                  <span class="code-comment">//Ver configuración actual</span>
                  git config --list
                  
                  <span class="code-comment">//Cambiar nombre</span>
                  git config --global user.name "Carlos Zabala Roqueme"

                  <span class="code-comment">//Cambiar email</span>
                  git config --global user.email "czabala847@gmail.com"
                </pre>
              </div>
            </article>
            <article class="course-class__section" id="show-diff">
              <h2 class="course-class__section--title">
                Analizar cambios en los archivos de tu proyecto con Git
              </h2>
              <div class="course-class__section--content">
                <p>
                  El comando <span class="t-bold">git show</span> nos muestra
                  los cambios que han existido sobre un archivo y es muy útil
                  para detectar cuándo se produjeron ciertos cambios, qué se
                  rompió y cómo lo podemos solucionar. Pero podemos ser más
                  detallados.
                </p>
                <p>
                  Si queremos ver la diferencia entre una versión y otra, no
                  necesariamente todos los cambios desde la creación del
                  archivo, podemos usar el comando
                  <span class="t-bold">git diff commitA commitB</span>.
                </p>
                <div class="note">
                  <p>
                    Recuerda que puedes obtener el ID de tus commits con el
                    comando <span class="t-bold">git log</span>.
                  </p>
                </div>
              </div>
            </article>
            <article class="course-class__section" id="checkout-reset">
              <h2 class="course-class__section--title">
                Reset y Checkout
              </h2>
              <div class="course-class__section--content">
                <p>
                  El comando <span class="t-bold">git checkout</span> + ID del
                  commit nos permite viajar en el tiempo. Podemos volver a
                  cualquier versión anterior de un archivo específico o incluso
                  del proyecto entero. Esta también es la forma de crear ramas y
                  movernos entre ellas.
                </p>
                <p>
                  También hay una forma de hacerlo un poco más "ruda": usando el
                  comando <span class="t-bold">git reset</span>. En este caso,
                  no solo "volvemos en el tiempo", sino que borramos los cambios
                  que hicimos después de este commit.
                </p>
                <p>
                  Hay dos formas de usar git reset: con el argumento
                  <span class="t-bold">--hard</span>, borrando toda la
                  información que tengamos en el área de staging (y perdiendo
                  todo para siempre). O, un poco más seguro, con el argumento
                  <span class="t-bold">--soft</span>, que mantiene allí los
                  archivos del área de staging para que podamos aplicar nuestros
                  últimos cambios pero desde un commit anterior.
                </p>
              </div>
            </article>
            <article class="course-class__section" id="remote-repo">
              <h2 class="course-class__section--title">
                Flujo de trabajo básico con un repositorio remoto
              </h2>
              <div class="course-class__section--content">
                <p>
                  <span class="t-bold">Servidores remotos</span>: un nuevo
                  estado que deben seguir nuestros archivos para conectarse y
                  trabajar con equipos de cualquier parte del mundo.
                </p>
                <p>
                  Estos servidores remotos pueden estar alojados en GitHub,
                  GitLab, BitBucket, entre otros. Lo que van a hacer es guardar
                  el mismo repositorio que tienes en tu computadora y darnos una
                  URL con la que todos podremos acceder a los archivos del
                  proyecto para descargarlos, hacer cambios y volverlos a enviar
                  al servidor remoto para que otras personas vean los cambios,
                  comparen sus versiones y creen nuevas propuestas para el
                  proyecto.
                </p>
                <p>Nuevos comandos:</p>
                <ul>
                  <li>
                    <span class="t-bold"
                      >git clone url_del_servidor_remoto:</span
                    >
                    Nos permite descargar los archivos de la última versión de
                    la rama principal y todo el historial de cambios en la
                    carpeta .git.
                  </li>
                  <li>
                    <span class="t-bold">git push: </span> Luego de hacer git
                    add y git commit debemos ejecutar este comando para mandar
                    los cambios al servidor remoto.
                  </li>
                  <li>
                    <span class="t-bold">git fetch:</span> Lo usamos para traer
                    actualizaciones del servidor remoto y guardarlas en nuestro
                    repositorio local (en caso de que hayan, por supuesto).
                  </li>
                  <li>
                    <span class="t-bold">git merge:</span> También usamos el
                    comando git fetch con servidores remotos. Lo necesitamos
                    para combinar los últimos cambios del servidor remoto y
                    nuestro directorio de trabajo.
                  </li>
                  <li>
                    <span class="t-bold">git pull:</span> Básicamente, git fetch
                    y git merge al mismo tiempo.
                  </li>
                </ul>
              </div>
            </article>
            <article class="course-class__section" id="git-brach">
              <h2 class="course-class__section--title">
                Introducción a las ramas o branches de Git
              </h2>
              <div class="course-class__section--content">
                <p>
                  Las ramas son la forma de hacer cambios en nuestro proyecto
                  sin afectar el flujo de trabajo de la rama principal. Esto
                  porque queremos trabajar una parte muy específica de la
                  aplicación o simplemente experimentar.
                </p>
                <p>
                  La cabecera o HEAD representan la rama y el commit de esa rama
                  donde estamos trabajando. Por defecto, esta cabecera aparecerá
                  en el último commit de nuestra rama principal.
                </p>
                <ul>
                  <li>
                    <span class="t-bold">git branch nombre-rama</span>: Crear
                    una nueva rama.
                  </li>
                  <li>
                    <span class="t-bold"
                      >git checkout nombre-rama-o-id-commit</span
                    >: Para movernos entre ramas o en el tiempo.
                  </li>
                </ul>
              </div>
            </article>
            <article class="course-class__section" id="git-merge">
              <h2 class="course-class__section--title">
                Fusión de ramas con Git merge
              </h2>
              <div class="course-class__section--content">
                <p>
                  El comando <span class="t-bold">git merge</span> nos permite
                  crear un nuevo commit con la combinación de dos ramas (la rama
                  donde nos encontramos cuando ejecutamos el comando y la rama
                  que indiquemos después del comando).
                </p>
                <div class="note">
                  <p>
                    Recuerda que al ejecutar el comando
                    <span class="t-bold">git checkout</span> para cambiar de
                    rama o commit puedes perder el trabajo que no hayas
                    guardado. Guarda tus cambios antes de hacer git checkout.
                  </p>
                </div>
              </div>
            </article>
            <article class="course-class__section" id="conflict-merge">
              <h2 class="course-class__section--title">
                Solución de conflictos al hacer un merge
              </h2>
              <div class="course-class__section--content">
                <p>
                  <span class="t-bold">Git nunca borra nada</span> a menos que
                  nosotros se lo indiquemos. Cuando usamos los comandos git
                  merge o git checkout estamos cambiando de rama o creando un
                  nuevo commit, no borrando ramas ni commits (recuerda que
                  puedes borrar commits con git reset y ramas con git branch
                  -d).
                </p>
                <p>
                  Git es muy inteligente y puede resolver algunos conflictos
                  automáticamente: cambios, nuevas líneas, entre otros. Pero
                  algunas veces no sabe cómo resolver estas diferencias, por
                  ejemplo, cuando dos ramas diferentes hacen cambios distintos a
                  una misma línea.
                </p>
                <p>
                  Esto lo conocemos como <span class="t-bold">conflicto</span> y
                  lo podemos resolver manualmente, solo debemos hacer el merge,
                  ir a nuestro editor de código y elegir si queremos quedarnos
                  con alguna de estas dos versiones o algo diferente. Algunos
                  editores de código como VSCode nos ayudan a resolver estos
                  conflictos sin necesidad de borrar o escribir líneas de texto,
                  basta con hundir un botón y guardar el archivo.
                </p>
                <p>
                  Recuerda que siempre debemos crear un nuevo commit para
                  aplicar los cambios del merge. Si Git puede resolver el
                  conflicto hará commit automáticamente. Pero, en caso de no
                  pueda resolverlo, debemos solucionarlo y hacer el commit.
                </p>
                <p>
                  Los archivos con conflictos por el comando git merge entran en
                  un nuevo estado que conocemos como
                  <span class="t-bold">Unmerged</span>. Funcionan muy parecido a
                  los archivos en estado Unstaged, algo así como un estado
                  intermedio entre Untracked y Unstaged, solo debemos ejecutar
                  git add para pasarlos al área de staging y git commit para
                  aplicar los cambios en el repositorio.
                </p>
              </div>
            </article>
          </div>
        </section>
        <footer class="footer">
          <div class="container-general">
            <div class="footer__container">
              <p id="footer-year">@Carlos Zabala Roqueme -</p>
              <figure class="footer__container--img">
                <img
                  src="../../images/logo-white-2.png"
                  alt="logo Carlos Zabala"
                />
              </figure>
            </div>
          </div>
        </footer>
      </div>
    </div>
    <script>
      const $menu = document.getElementById("btn-menu");
      const $courseMenu = document.getElementById("course-class__left");

      $menu.addEventListener("click", handleClick);

      function handleClick() {
        $courseMenu.classList.toggle("is-active");
        $menu.classList.toggle("is-active");

        if ($menu.classList.contains("icon-menu")) {
          $menu.classList.remove("icon-menu");
          $menu.classList.add("icon-close");
        } else {
          $menu.classList.remove("icon-close");
          $menu.classList.add("icon-menu");
        }
      }

      const $footerYear = document.getElementById("footer-year");

      let date = new Date();

      $footerYear.innerHTML += " " + date.getFullYear();
    </script>
  </body>
</html>
